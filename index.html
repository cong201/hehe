<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <title>Gi√°ng Sinh Lung Linh t·∫∑ng Mai Linh üéÑ‚ù§Ô∏è</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #020205;
      }
      canvas {
        display: block;
      }

      #message {
        position: absolute;
        top: 30px;
        width: 100%;
        text-align: center;
        font-family: "Pacifico", cursive;
        color: #fff;
        font-size: 2.5em;
        pointer-events: none;
        z-index: 10;
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
      }

      .btn {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 40px;
        background: linear-gradient(45deg, #ff3366, #ff0000);
        color: white;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        font-family: sans-serif;
        box-shadow: 0 5px 25px rgba(255, 0, 68, 0.6);
        transition: 0.4s;
        z-index: 100;
      }
      .btn:hover {
        transform: translateX(-50%) scale(1.1);
        box-shadow: 0 8px 35px rgba(255, 0, 68, 0.9);
      }

      #center-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Pacifico", cursive;
        color: #ffffff;
        font-size: 3em;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 2s ease-in-out;
        z-index: 5;
        pointer-events: none;
        text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 40px #ff00de,
          0 0 80px #ff00de;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="message">Merry Christmas üéÑ</div>
    <div id="center-text">Mai Linh</div>

    <audio id="bgMusic" loop>
      <source src="https://files.catbox.moe/v1r2ab.mp3" type="audio/mpeg" />
    </audio>

    <button class="btn" id="animBtn">G·ª≠i t·∫∑ng Mai Linh ‚ù§Ô∏è</button>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // --- C·∫§U H√åNH ---
      const STAR_URL =
        "https://cdn-icons-png.flaticon.com/128/1828/1828884.png";
      // Icon b√°nh sinh nh·∫≠t (nh∆∞ trong ·∫£nh b·∫°n g·ª≠i) ho·∫∑c qu√†
      const GIFT_URL =
        "https://cdn-icons-png.flaticon.com/128/4213/4213654.png";

      const PARTICLE_COUNT = 20000;
      const PARTICLE_SIZE = 0.22;

      // Kho·∫£ng c√°ch t·ªëi thi·ªÉu gi·ªØa c√°c icon ƒë·ªÉ kh√¥ng b·ªã ƒë√® (s·ªë c√†ng l·ªõn c√†ng th∆∞a)
      const MIN_DISTANCE_BETWEEN_ICONS = 3.0;

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x020205, 0.012);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 40);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.8;
      controls.maxPolarAngle = Math.PI / 1.5;

      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);

      const texLoader = new THREE.TextureLoader();

      // --- D·ªÆ LI·ªÜU H·∫†T ---
      const geometry = new THREE.BufferGeometry();
      const colors = [];
      const treePositions = [];
      const heartPositions = [];
      const currentPositions = [];
      const colorObj = new THREE.Color();

      // 1. C√ÇY TH√îNG
      const treeHeight = 24;
      const treeBaseRadius = 10;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const h = Math.random() * treeHeight;
        const angle = Math.random() * Math.PI * 2;
        const r =
          ((treeHeight - h) / treeHeight) * treeBaseRadius * Math.random();
        const x = r * Math.cos(angle);
        const y = h - treeHeight / 2;
        const z = r * Math.sin(angle);
        treePositions.push(x, y, z);
        currentPositions.push(x, y, z);
        const rnd = Math.random();
        if (rnd < 0.05) colorObj.setHex(0xffd700);
        else if (rnd < 0.1) colorObj.setHex(0xff3333);
        else
          colorObj.setHSL(
            0.35 + Math.random() * 0.1,
            0.8,
            0.3 + Math.random() * 0.3
          );
        colors.push(colorObj.r, colorObj.g, colorObj.b);
      }

      // 2. TR√ÅI TIM R·ªñNG
      const scaleOverall = 0.75;
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const t = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI * 2;
        const x2d = Math.abs(16 * Math.pow(Math.sin(t), 3));
        const y2d =
          13 * Math.cos(t) -
          5 * Math.cos(2 * t) -
          2 * Math.cos(3 * t) -
          Math.cos(4 * t);
        const thicknessBase = 1.0;
        const thicknessVariation = 0.25 * (Math.random() - 0.5);
        const radiusScale = thicknessBase + thicknessVariation;
        const finalX = x2d * radiusScale * Math.cos(phi) * scaleOverall;
        const finalY = y2d * radiusScale * scaleOverall;
        const finalZ = x2d * radiusScale * Math.sin(phi) * scaleOverall;
        heartPositions.push(finalX, finalY, finalZ);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(currentPositions, 3)
      );
      geometry.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(colors, 3)
      );

      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- TRANG TR√ç TH√îNG MINH (KH√îNG ƒê√à NHAU) ---
      const decoSprites = [];
      const decoGroup = new THREE.Group();
      scene.add(decoGroup);

      // M·∫£ng l∆∞u v·ªã tr√≠ c√°c v·∫≠t ƒë√£ ƒë·∫∑t ƒë·ªÉ ki·ªÉm tra va ch·∫°m
      const occupiedPositions = [];

      // Th√™m v·ªã tr√≠ ƒë·ªânh c√¢y v√†o danh s√°ch ƒë√£ chi·∫øm ch·ªó tr∆∞·ªõc
      occupiedPositions.push(new THREE.Vector3(0, treeHeight / 2 + 0.5, 0));

      function createDecoSmart(textureUrl, count, baseScale, yOffset) {
        texLoader.load(textureUrl, (texture) => {
          const mat = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            opacity: 1.0,
          });

          let placedCount = 0;
          let attempts = 0;
          // Th·ª≠ t·ªëi ƒëa 1000 l·∫ßn ƒë·ªÉ t√¨m ch·ªó tr·ªëng, tr√°nh treo tr√¨nh duy·ªát
          const maxAttempts = 1000;

          while (placedCount < count && attempts < maxAttempts) {
            attempts++;

            // 1. Random v·ªã tr√≠ ng·∫´u nhi√™n
            const h = Math.random() * (treeHeight - 2); // Tr·ª´ b·ªõt ƒë·ªânh v√† ƒë√°y x√≠u
            const angle = Math.random() * Math.PI * 2;
            const r = ((treeHeight - h) / treeHeight) * treeBaseRadius + 0.5;

            const x = r * Math.cos(angle);
            const y = h - treeHeight / 2 + yOffset;
            const z = r * Math.sin(angle);

            const newPos = new THREE.Vector3(x, y, z);

            // 2. Ki·ªÉm tra va ch·∫°m v·ªõi T·∫§T C·∫¢ c√°c v·∫≠t ƒë√£ ƒë·∫∑t tr∆∞·ªõc ƒë√≥
            let isOverlapping = false;
            for (const existingPos of occupiedPositions) {
              // N·∫øu kho·∫£ng c√°ch < gi·ªõi h·∫°n cho ph√©p => ƒê√® nhau
              if (newPos.distanceTo(existingPos) < MIN_DISTANCE_BETWEEN_ICONS) {
                isOverlapping = true;
                break;
              }
            }

            // 3. N·∫øu kh√¥ng ƒë√® th√¨ ƒë·∫∑t v√†o
            if (!isOverlapping) {
              const sprite = new THREE.Sprite(mat);
              sprite.position.copy(newPos);

              // Random k√≠ch th∆∞·ªõc
              const s = baseScale * (0.8 + Math.random() * 0.4);
              sprite.scale.set(s, s, 1);

              // V·∫≠n t·ªëc bay
              sprite.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                0.2 + Math.random() * 0.3,
                (Math.random() - 0.5) * 0.2
              );

              decoGroup.add(sprite);
              decoSprites.push(sprite);

              // L∆∞u v·ªã tr√≠ n√†y v√†o danh s√°ch ƒë√£ chi·∫øm ch·ªó
              occupiedPositions.push(newPos);
              placedCount++;
            }
          }

          if (placedCount < count) {
            console.log(
              `Ch·ªâ ƒë·∫∑t ƒë∆∞·ª£c ${placedCount}/${count} v·∫≠t do h·∫øt ch·ªó tr·ªëng!`
            );
          }
        });
      }

      // G·ªåI H√ÄM T·∫†O V·∫¨T TRANG TR√ç
      // S·ªë l∆∞·ª£ng √≠t v·ª´a ph·∫£i ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ ch·ªó tr·ªëng
      createDecoSmart(STAR_URL, 18, 1.5, 0);
      createDecoSmart(GIFT_URL, 12, 1.8, -0.5);

      // Ng√¥i sao ƒë·ªânh (Gi·ªØ nguy√™n)
      texLoader.load(STAR_URL, (texture) => {
        const topStar = new THREE.Sprite(
          new THREE.SpriteMaterial({ map: texture })
        );
        topStar.position.set(0, treeHeight / 2 + 0.5, 0);
        topStar.scale.set(4, 4, 1);
        topStar.userData.velocity = new THREE.Vector3(0, 0.5, 0);
        decoGroup.add(topStar);
        decoSprites.push(topStar);
      });

      // --- ANIMATION ---
      let state = "tree";
      let progress = 0;

      document.getElementById("animBtn").addEventListener("click", () => {
        if (state === "tree") {
          const audio = document.getElementById("bgMusic");
          audio.play().catch((error) => {
            console.log("L·ªói autoplay nh·∫°c");
          });

          state = "exploding";
          progress = 0;
          document.getElementById("animBtn").style.opacity = 0;
          setTimeout(
            () => (document.getElementById("animBtn").style.display = "none"),
            500
          );

          document.getElementById("message").innerHTML =
            "D√†nh t·∫∑ng Mai Linh ‚ù§Ô∏è";
          controls.autoRotateSpeed = 2.0;
        }
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const posAttr = particles.geometry.attributes.position;

        if (state === "exploding") {
          progress += 0.008;
          if (progress > 1) progress = 1;

          const explosionFactor = Math.sin(progress * Math.PI) * 3;
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const tx = treePositions[ix],
              ty = treePositions[ix + 1],
              tz = treePositions[ix + 2];
            const hx = heartPositions[ix],
              hy = heartPositions[ix + 1],
              hz = heartPositions[ix + 2];
            posAttr.array[ix] =
              tx +
              (hx - tx) * progress +
              (Math.random() - 0.5) * explosionFactor * 0.05;
            posAttr.array[ix + 1] =
              ty +
              (hy - ty) * progress +
              (Math.random() - 0.5) * explosionFactor * 0.05;
            posAttr.array[ix + 2] = tz + (hz - tz) * progress;
          }
          posAttr.needsUpdate = true;

          const colorAttr = particles.geometry.attributes.color;
          if (progress < 0.8) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
              if (Math.random() > 0.96) {
                colorObj.setHSL(0.95 + Math.random() * 0.05, 0.9, 0.5);
                colorAttr.array[i * 3] = colorObj.r;
                colorAttr.array[i * 3 + 1] = colorObj.g;
                colorAttr.array[i * 3 + 2] = colorObj.b;
              }
            }
            colorAttr.needsUpdate = true;
          }

          decoSprites.forEach((sprite) => {
            sprite.position.add(sprite.userData.velocity);
            sprite.material.opacity -= 0.01;
            if (sprite.material.opacity < 0) sprite.visible = false;
          });

          if (progress === 1) {
            state = "heart";
            controls.autoRotateSpeed = 0.8;
          }
        } else if (state === "heart") {
          const time = Date.now() * 0.0015;
          const scale = 1 + Math.sin(time) * 0.03;
          particles.scale.set(scale, scale, scale);

          document.getElementById("center-text").style.opacity = 1;
        }
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
