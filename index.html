<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <title>Gi√°ng Sinh Lung Linh t·∫∑ng Mai Linh üéÑ‚ù§Ô∏è</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #020205;
      }
      canvas {
        display: block;
      }

      /* D√≤ng ch·ªØ Merry Christmas ·ªü tr√™n c√πng */
      #message {
        position: absolute;
        top: 30px;
        width: 100%;
        text-align: center;
        font-family: "Pacifico", cursive;
        color: #fff;
        font-size: 2.5em;
        pointer-events: none;
        z-index: 10;
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
      }

      /* N√∫t b·∫•m */
      .btn {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 40px;
        background: linear-gradient(45deg, #ff3366, #ff0000);
        color: white;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        font-family: sans-serif;
        box-shadow: 0 5px 25px rgba(255, 0, 68, 0.6);
        transition: 0.4s;
        z-index: 100;
      }
      .btn:hover {
        transform: translateX(-50%) scale(1.1);
        box-shadow: 0 8px 35px rgba(255, 0, 68, 0.9);
      }

      /* ƒê√ÇY L√Ä CH·ªÆ T√äN NG∆Ø·ªúI TH∆Ø∆†NG (N·∫±m gi·ªØa m√†n h√¨nh) */
      #center-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Pacifico", cursive;
        color: #ffffff;
        font-size: 3em;
        white-space: nowrap;
        opacity: 0; /* Ban ƒë·∫ßu ·∫©n */
        transition: opacity 2s ease-in-out;
        z-index: 5;
        pointer-events: none;
        text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 40px #ff00de,
          0 0 80px #ff00de;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="message">Merry Christmas üéÑ</div>
    <div id="center-text">Mai Linh</div>
    <button class="btn" id="animBtn">G·ª≠i t·∫∑ng Mai Linh ‚ù§Ô∏è</button>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // --- C·∫§U H√åNH ---
      // Ch·ªâ gi·ªØ l·∫°i link Sao v√† Qu√†, x√≥a link K·∫πo/Ch√¨a kh√≥a ƒëi
      const STAR_URL =
        "https://cdn-icons-png.flaticon.com/128/1828/1828884.png";
      const GIFT_URL =
        "https://cdn-icons-png.flaticon.com/128/4213/4213654.png";

      const PARTICLE_COUNT = 20000;
      const PARTICLE_SIZE = 0.22;

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x020205, 0.012);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 40);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.8;
      controls.maxPolarAngle = Math.PI / 1.5;

      // --- √ÅNH S√ÅNG ---
      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);

      const texLoader = new THREE.TextureLoader();

      // --- D·ªÆ LI·ªÜU H·∫†T ---
      const geometry = new THREE.BufferGeometry();
      const colors = [];
      const treePositions = [];
      const heartPositions = [];
      const currentPositions = [];
      const colorObj = new THREE.Color();

      // 1. C√ÇY TH√îNG
      const treeHeight = 24;
      const treeBaseRadius = 10;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const h = Math.random() * treeHeight;
        const angle = Math.random() * Math.PI * 2;
        const r =
          ((treeHeight - h) / treeHeight) * treeBaseRadius * Math.random();
        const x = r * Math.cos(angle);
        const y = h - treeHeight / 2;
        const z = r * Math.sin(angle);
        treePositions.push(x, y, z);
        currentPositions.push(x, y, z);
        const rnd = Math.random();
        if (rnd < 0.05) colorObj.setHex(0xffd700);
        else if (rnd < 0.1) colorObj.setHex(0xff3333);
        else
          colorObj.setHSL(
            0.35 + Math.random() * 0.1,
            0.8,
            0.3 + Math.random() * 0.3
          );
        colors.push(colorObj.r, colorObj.g, colorObj.b);
      }

      // 2. TR√ÅI TIM R·ªñNG
      const scaleOverall = 0.75;
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const t = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI * 2;
        const x2d = Math.abs(16 * Math.pow(Math.sin(t), 3));
        const y2d =
          13 * Math.cos(t) -
          5 * Math.cos(2 * t) -
          2 * Math.cos(3 * t) -
          Math.cos(4 * t);
        const thicknessBase = 1.0;
        const thicknessVariation = 0.25 * (Math.random() - 0.5);
        const radiusScale = thicknessBase + thicknessVariation;
        const finalX = x2d * radiusScale * Math.cos(phi) * scaleOverall;
        const finalY = y2d * radiusScale * scaleOverall;
        const finalZ = x2d * radiusScale * Math.sin(phi) * scaleOverall;
        heartPositions.push(finalX, finalY, finalZ);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(currentPositions, 3)
      );
      geometry.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(colors, 3)
      );

      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- TRANG TR√ç (ƒê√£ th√™m l·∫°i ph·∫ßn n√†y) ---
      const decoSprites = [];
      const decoGroup = new THREE.Group();
      scene.add(decoGroup);

      function createDeco(textureUrl, count, baseScale, yOffset) {
        texLoader.load(textureUrl, (texture) => {
          const mat = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            opacity: 1.0,
          });
          for (let i = 0; i < count; i++) {
            const sprite = new THREE.Sprite(mat);
            const h = Math.random() * treeHeight;
            const angle = Math.random() * Math.PI * 2;
            const r = ((treeHeight - h) / treeHeight) * treeBaseRadius + 0.5;
            sprite.position.set(
              r * Math.cos(angle),
              h - treeHeight / 2 + yOffset,
              r * Math.sin(angle)
            );
            const s = baseScale * (0.8 + Math.random() * 0.4);
            sprite.scale.set(s, s, 1);
            sprite.userData.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.2,
              0.2 + Math.random() * 0.3,
              (Math.random() - 0.5) * 0.2
            );
            decoGroup.add(sprite);
            decoSprites.push(sprite);
          }
        });
      }

      // CH·ªà G·ªåI T·∫†O SAO V√Ä QU√Ä
      createDeco(STAR_URL, 50, 1.5, 0);
      createDeco(GIFT_URL, 30, 1.8, -1);
      // ƒê√£ x√≥a d√≤ng t·∫°o CANDY_URL (ch√¨a kh√≥a)

      // Ng√¥i sao ƒë·ªânh
      texLoader.load(STAR_URL, (texture) => {
        const topStar = new THREE.Sprite(
          new THREE.SpriteMaterial({ map: texture })
        );
        topStar.position.set(0, treeHeight / 2 + 0.5, 0);
        topStar.scale.set(4, 4, 1);
        topStar.userData.velocity = new THREE.Vector3(0, 0.5, 0);
        decoGroup.add(topStar);
        decoSprites.push(topStar);
      });

      // --- ANIMATION ---
      let state = "tree";
      let progress = 0;

      document.getElementById("animBtn").addEventListener("click", () => {
        if (state === "tree") {
          state = "exploding";
          progress = 0;
          document.getElementById("animBtn").style.opacity = 0;
          setTimeout(
            () => (document.getElementById("animBtn").style.display = "none"),
            500
          );
          document.getElementById("message").innerHTML =
            "D√†nh t·∫∑ng Mai Linh ‚ù§Ô∏è";
          controls.autoRotateSpeed = 2.0;
        }
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const posAttr = particles.geometry.attributes.position;

        if (state === "exploding") {
          progress += 0.008;
          if (progress > 1) progress = 1;

          const explosionFactor = Math.sin(progress * Math.PI) * 3;
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const tx = treePositions[ix],
              ty = treePositions[ix + 1],
              tz = treePositions[ix + 2];
            const hx = heartPositions[ix],
              hy = heartPositions[ix + 1],
              hz = heartPositions[ix + 2];
            posAttr.array[ix] =
              tx +
              (hx - tx) * progress +
              (Math.random() - 0.5) * explosionFactor * 0.05;
            posAttr.array[ix + 1] =
              ty +
              (hy - ty) * progress +
              (Math.random() - 0.5) * explosionFactor * 0.05;
            posAttr.array[ix + 2] = tz + (hz - tz) * progress;
          }
          posAttr.needsUpdate = true;

          // ƒê·ªïi m√†u h·∫°t
          const colorAttr = particles.geometry.attributes.color;
          if (progress < 0.8) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
              if (Math.random() > 0.96) {
                colorObj.setHSL(0.95 + Math.random() * 0.05, 0.9, 0.5);
                colorAttr.array[i * 3] = colorObj.r;
                colorAttr.array[i * 3 + 1] = colorObj.g;
                colorAttr.array[i * 3 + 2] = colorObj.b;
              }
            }
            colorAttr.needsUpdate = true;
          }

          // Hi·ªáu ·ª©ng bay l√™n cho c√°c icon trang tr√≠ (ƒë√£ th√™m l·∫°i)
          decoSprites.forEach((sprite) => {
            sprite.position.add(sprite.userData.velocity);
            sprite.material.opacity -= 0.01;
            if (sprite.material.opacity < 0) sprite.visible = false;
          });

          if (progress === 1) {
            state = "heart";
            controls.autoRotateSpeed = 0.8;
          }
        } else if (state === "heart") {
          const time = Date.now() * 0.0015;
          const scale = 1 + Math.sin(time) * 0.03;
          particles.scale.set(scale, scale, scale);

          document.getElementById("center-text").style.opacity = 1;
        }
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
